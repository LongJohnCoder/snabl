* fix memory leak
** clear func imps in Lib destructor
* add macro support
** name arity macros xxx:
*** process all passed in tokens
* add Sexpr support
** add Sexpr form
*** eval separately
* add set/del places
** add []-support
*** parse as func '[]' and call with args
** add Eval enum
*** enum class Eval {Get/Set/Del}
*** add Fimp.eval
**** print after name at:del<Str Int>
*** add set: macro
**** ('foo'[1] set: ..)
**** modify previous op during compilation
*** add del macro
**** ('foo'[1] del)
**** modify previous op during compilation
del: macros that modify the next func/var
***** add Set/Del ops
***** check that Set/Del is followed by Funcall/GetVar
* add , support
** eval rest separately on each comma
* finish fib support
* add repl(env, in, out) fn
** eval snabl code
* add ops PushCall PopCall
* exec funcs/macros without args immediately
** otherwise at end of expr or ,
* add optional func.parent_scope
** use as parent for begin
* precompile fimps
** compile rest on demand
* add jump op
** ssize_t nops
** update pc
* add drop/swap/reset ops
* add set/get_var ops
* add env.push/pop_scope
** update stack_begin in push
* add recall op
** jump immediately
** remember scope iter and truncate before jump
* add generics
** add Type._args
*** deque of ATypePtrs
** add Type.specialize(type, ...)
*** check types
** add virtual protected Type.specialize()
*** override to create new instance
** add Sink<T>
*** add push fn
* add code generation
** generate function
*** take env param
** snabl compile/build
** generate harness with env
** add OpType.emit_cpp fn
*** generate code to emit op on env bin
* add fimp lookup
** add lib.fimps/add_fimp
*** call from func when fimp is added
*** use instead of add_func
** adapt id-parse to handle <..>
** call get_fimp instead of get_func if id contains '<'
* add sqlite plugin
* add wxwidgets plugin
* add proxygen plugin
